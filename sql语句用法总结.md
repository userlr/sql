# sql
对sql语句用法，注意事项的总结
# 索引问题
 索引的作用是用来提高查询速度的，为表加上索引，可以避免每次查询都需要遍历整个表，
 但是添加索引会降低增删改查的速度，占用物理空间，更新索引的速度 也很慢
## 主键索引与非主键索引的区别
 主键索引（聚簇索引）是直接对应一整行数据的，而非主键索引（二级索引）是先对应主键索引，在通过主键索引寻找想要的数据的。
 所以使用主键索引比非主键索引要快的。而且使用主键索引时要尽量使用主键自增，因为对于主键索引的树是有序的，
 当你向中间插入某行数据时，需要将下面的叶子节点移动，如果这页数据满了，还有可能需要进行页分裂的操作，会浪费大量时间。
 而使用自增主键就不会遇到这种情况，因为每次插入的主键都会比前面的大，会直接在后面插入，不需要叶子节点移动。
## SQL语句运行慢的问题
### 偶尔很慢
  这种情况的最大可能性有两种情况：
  一种是数据库刷新，当我们要往数据库插入一条数据、或者要更新一条数据的时候，
数据库会在内存中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到磁盘中去，
而是把这些更新的记录写入到 redo log 日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到磁盘中去。
但是，redo log 里的容量是有限的，如果数据库频繁更新， redo log 很快就会被写满了，就没办法等到空闲的时候再把数据同步到磁盘的，
只能暂停其他操作，把数据同步到磁盘中去的，就会导致我们平时正常的SQL语句突然执行的很慢





另一种就是我们要执行的这条语句，刚好这条语句涉及到的表，表上加了锁，只能等待别人用完你才能使用，
或者某一句加了锁，也需要等待。要判断是否真的在等待锁，我们可以用 show processlist这个命令来查看当前的状态。
### 一直很慢
 这个时候运行一直很慢就需要用到索引了，但是加了索引不等于用上了索引，有可能对字段的运行，函数操作等导致无法使用索引。
 1.字段没有索引，运行自然很慢
 
 2.字段有索引，但却没有用索引
 
    2.1自己输入索引有误，导致系统无法实现索引功能。
     例如：
       select * from t where c - 1 = 1000;
        我们在字段的左边做了运算，在查询的时候，就不会用上索引了
      正确的查询如下：
        select * from t where c = 1000 + 1;
    2.2函数操作导致没有用上索引
    例如：
    select * from t where pow(c,2) = 1000;
    假设函数 pow 是求 c 的 n 次方，实际上可能并没有 pow(c,2)这个函数。其实这个和上面在左边做运算也是很类似的。
    而这种情况需要你自己分析哪里出现了问题
    2.3系统自己选错了索引
    例如：
    select * from t where 100 < c and c < 100000;
    由于非主键索引是通过主键索引在找到对应值的，也就意味着需要走两次索引，而系统自己会判断如何走回使得步数最少
    但是如果查找值是全部数据，也就意味着系统不仅要走完全表，还要走两次索引。
    所以，系统会预测使用索引有可能扫描的行数，而系统判断行数的依据是索引的基数。
    系统是通过索引的区分度来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。
    我们也把区分度称之为基数，即区分度越高，基数越大。所以呢，基数越大，意味着符合 100 < c and c < 10000 这个条件的行数越少。
    索引的基数，是索引系统是通过遍历部分数据，也就是通过采样的方式，来预测索引的基数的。
     
     
     即系统通过基数判断索引查找行数较多（因为这种采样判断不准确），所以自行选择全表扫描，自然会导致系统运行缓慢
     所以索引最好只对应一行。
     
     
     不过呢，我们有时候也可以通过强制走索引的方式来查询，
     例如：
        select * from t force index(a) where c < 100 and c < 100000;
     或者：
        show index from t;

